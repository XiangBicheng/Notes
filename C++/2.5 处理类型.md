# 2.5 处理类型

随着程序的复杂性增加，程序中用到的类型的复杂性也会增加，需要一些方法更好地操作类型。

## 2.5.1 类型别名

- **类型别名**是某种类型的同义词。有两种方式可以用来定义类型别名：

  ```c++
  typedef double wages;	//wages是double类型的同义词
  typedef wages base, *p; //base是double的同义词，p是double*的同义词

  using SI = Sales_item;  //SI是Sales_item的同义词
  ```

- 如果某个类型别名指代的是复合类型，如指针，那么const修饰的基本数据类型指的是该指针本身是常量指针，在这种情况下直接将类型别名替换为它本来的样子就是错误的：

  ```c++
  typedef char *pstring;
  const pstring cstr = 0; //cstr是指向char的常量指针
  const pstring *ps; 	    //ps是一个指针，它指向的对象是指向char的常量指针
  ```

## 2.5.2 auto类型说明符

- 编程时常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚地知道表达式的类型。但这一点在实践中，有时候是很难做到的。C++中引入**auto**类型说明符，用它就能让编译器替我们去分析表达式所属的类型。使用auto在同一行中声明多个变量的时候要满足这些变量的初始数据类型一致，因为一条声明语句只能有一个基本数据类型。

- 编译器推断出来的auto类型有时候与初始值的类型并不完全一样，编译器会适当地调整结果以符合正常的初始化规则。

  - 首先，使用引用其实是使用引用指代的对象，当引用作为初始值赋给变量的时候，实际参与初始化的是引用指代的对象，故auto的结果是引用指代的对象的类型：

    ```c++
    int i = 0, &r = i;
    auto a = r;		// a是一个整数
    ```

  - 其次，auto一般会忽略掉顶层const，保留底层const：

    ```c++
    const int ci = i, &cr = ci;
    auto b = ci;	// b是一个整数，顶层const忽略
    auto c = cr;	// 使用cr与使用ci的效果一样
    auto d = &i;	// d是一个整型指针
    auto e = &ci;	// e是一个指向整数常量的指针，&cr是一个指向整型常量的指针，也就是底层const
    ```

    如果希望推断出的auto类型是一个顶层const，需要明确指出：

    ```c++
    const auto f = ci // ci的推断类型是int，f是const int
    ```

  - 可以定义auto类型的引用，原来和引用相关的初始化规则仍然适用。

## 2.5.3 decltype类型指示符

- 有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。C++引入**decltype**，它的作用是选择并返回操作数的数据类型，在此过程中，编译器分析表达式的值并得到它的类型，但不实际计算表达式的值：

  ```c++
  decltype(f()) sum = x; // sum的类型就是函数f的返回类型
  ```

- decltype返回的类型与提供的参数变量的实际类型是完全一致的，如果参数变量的类型是顶层const，那么decltype得到的也是顶层const；如果参数变量是个引用，那么decltype得到的类型也是引用，引用从来都是作为其所指对象的同义词出现，只有这里是个例外：

  ```c++
  const int ci = 0, &cj = ci;
  decltype(ci) x = 0;	// x的类型是const int
  decltype(cj) y = x; // y的类型是const int&
  decltype(cj) z;	    // 报错：z是一个引用，必须初始化
  ```

- 如果decltype使用的表达式不是一个变量，则decltype将返回表达式结果对应的类型：

  ```
  int i = 42, *p = &i, &r = i;
  decltype(r + 0) b;	// 正确：加法的结果是int，b是未初始化的int类型
  decltype(*p) c;		// 错误：c是一个整型引用，int&，必须初始化
  ```

  上述代码中，因为r是一个引用，因此如果想要得到r指向的对象的类型，可以把r作为表达式的一部分，如r+0，这样decltype的结果就是该引用指向的int类型了；另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型，其实这是显然的，因为*p得到的就是指针指向对象的别名，即引用（也是为什么这个操作叫做解引用的原因）。

- 有一个重要的特性是，decltype的结果与表达式的形式密切相关，具体而言，decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身是个引用时才是引用：

  ```c++
  decltype((i)) d; // 错误：d是整型引用，int&，必须初始化
  decltype(i) e;	 // 正确：e是一个为初始化的int
  ```

## 练习

- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。如果i是int，则表达式`i = x`的类型就是int&。
- auto和decltype的区别：1. 处理顶层const和引用的方式不同；2. decltype的结果和表达式的形式有关。