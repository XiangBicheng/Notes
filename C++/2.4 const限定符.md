# 2.4 const限定符

- 有时候，我们需要定义这样一种变量，它的值在初始化后不能被改变，这时，使用*const*关键字。注意，和引用类型一样，*const*变量必须进行初始化。

- 默认情况下*const*关键字定义的变量，只在文件内有效，如果在多个文件中使用*const*定义了相同名称的变量，则它们是不同的变量；如果要让*const*变量在多个文件之间共享，则不管是声明还是定义，都加上*extern*关键字。

- 可以把引用绑定到*const*对象上，称之为**对常量的引用**，在创建对常量的引用时，也要使用*const*关键字修饰声明语句中的基本数据类型，这是后面提到的底层const；如果不使用const关键字，将会报错。

- 普通的非常量引用只能和已存在的非常量**对象**绑定，而常量引用则可以与非常量的对象、字面值，甚至一个一般表达式绑定。如果常量引用绑定的是一个非常量的对象，那么虽然不能通过该常量引用改变对应对象的值，但可以通过其他途径改变对应对象的值，如直接给该非常量对象赋值。

- 可以使指针指向*const*对象，称之为**指向常量的指针**，在创建指向常量的指针时，也要使用*const*关键字修饰声明语句中的基本数据类型，这是后面提到的底层const；如果不使用*const*关键字，将会报错。

- 普通的指针只能指向对应类型的非常量对象，而指向常量的指针可以指向对应类型的非常量对象。如果指向常量的指针指向的是非常量对象，那么虽然不能通过该指针改变对应对象的值，但可以通过其他途径改变对应对象的值。

- Tip：所谓指向常量的指针或引用，只不过是那些指针或引用的“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值，而实际上，通过其他途径这些对象的值是可以改变的。

- **常量指针**：指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定义为常量，称为常量指针。常量指针必须初始化，一旦初始化完成，该指针就变为只读，将永远指向某一特定对象。能否通过常量指针改变其指向的那个对象的值取决于指针定义时的基本数据类型部分是否加了const关键字，也就是是否属于底层const。

- 由于指针本身是个对象，它又可以指向另外一个对象。因此指针本身是不是个常量和指针所指的对象是不是一个常量就是两个相互独立的问题。用名词**顶层const**（top-level const）表示指针本身是个常量；用名词**底层const**（low-level const）表示指针所指的对象是个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任意数据类型都适用，如算术类型、类、指针等；底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const，这一点和其他类型相比区别明显。

- 底层const对赋值或初始化施加限制，例如一个底层const的指针p1，不能被赋值给一个非底层const的指针p2，但反过来，非底层const的指针p2是可以被赋值给底层const的指针p1的。

- 常量表达式（const expression）是指值不会改变并且在编译过程中就能得到计算结果的表达式。比较来说，const并未区分出其修饰的对象是编译期常量还是运行期常量，而常量表达式则将其修饰的对象限制为编译期常量。由于C++语言中由几种情况下是要用到常量表达式的，而在一个复杂系统中，我们是很难分辨一个初始值到底是不是常量表达式的，所以C++语言提供了一个*constexpr*关键字。该关键字修饰的变量，编译器在编译的时候会检查其是否为常量表达式。

- 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr，0，或者是存储于某个固定地址中的对象。注意，函数体内定义的变量一般来说并非存放在固定的地址中，而定义于所有函数体之外的对象其地址固定不变。因此，前者不能用来初始化constexpr指针，而后者能。还必须明确的一点是，如果在constexpr声明中定义了一个指针，限定符constexpr仅用来修饰指针，而与指针指向的对象无关，如果你要求指针指向的对象是常量，你需要将基本数据类型部分加上const，例如：`constexpr const int *p = &i;`。

  ​