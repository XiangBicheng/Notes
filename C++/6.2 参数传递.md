# 6.2 参数传递

- 每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。
  - 当形参是引用类型时，我们说它对应的实参被**引用传递(passed by reference)**或者函数被**传引用调用(called by reference)**。此时，引用形参是它对应的实参的别名。
  - 当实参的值被拷贝给形参的时候，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递(passed by value)**或者函数被**传值引用(called by value)**。

## 1. 传值参数

- 任何通过值传递的形参都不能改变调用者传递的实参的值。指针形参和其他非引用类型的形参一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝过后，两个指针是不同的指针，但它们指向相同的对象。所以，当我们通过指针形参改变其所指对象的值过后， 对应实参所指对象的值也发生了改变。

*tip：熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参代替指针。*

## 2. 传引用参数

- 使用引用形参改变传入实参的值。
- 使用引用形参避免拷贝。

*tip：如果函数无需改变引用形参的值，最好将其声明为常量引用。*

- 使用引用形参返回额外信息：这是解决函数需要返回多个值情形的可行方式。

## 3. const 形参和实参

- **尽量使用常量引用**。把函数不会改变的形参定义成(普通的)引用不只是编码风格不好，而应该被视为一种错误。具体讨论见p192。

## 4. 数组形参

- 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组；使用数组时通常会自动将其转换成指针。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为一个函数传递数组时，实际上传递的是指向数组首元素的指针。

  尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

  ```c++
  // 以下三种函数是等价的
  void print(const int*);
  void print(const int[]); 
  void print(const int[10]); 
  ```

- 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸。处理这个问题，有三种常用的技术：

  - 要求数组本身包含一个结束标记，比如字符数组我们可以在函数内部通过其结尾的空字符判定范围；
  - 同时传递数组首元素指针和尾后指针，可以借助begin和end函数；
  - 增加一个参数，显式地表示数组的大小。

- C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。

  ```c++
  // 形参中的括号不能少
  void print(int (&arr)[10])
  {
  	for (auto elem : arr)
  		cout << elem << endl;
  }
  ```

- **传递多维数组**实际上是传递指向数组首元素的指针。以下两种方式等价：

  ```c++
  // 形参中的括号不能少
  void print(int (*matrix)[10], int rowSize) { /* . . . */ }
  ```

  ```c++
  // 第一个方括号的数组省不省略都没关系，因为编译器会一如既往的忽略第一个维度。
  // 第二个维度及后面的所有维度的大小都不能省略，因为它们是数组类型的一部分。
  void print(int matrix[][10], int rowSize) { /* . . . */ }
  ```


## 5. main：处理命令行选项

- 可以给main函数传入命令行参数：

  ```c++
  // 命令：prog -d -o ofile data0
  // argc表示参数个数，应该为5
  // argv是数组，其元素为指向char *的指针，也就是C风格的字符串
  int main(int argc, char *argv[]) { ... }
  ```

  ```c++
  // 另一种参数形式
  int main(int argc, char **argv) { ... }
  ```

## 6. 含有可变形参的函数

- 为了编写能处理不同数量实参的函数，C++11提供了两种主要的方法：
  - 使用名为initializer_list的标准库类型，要求传递的所有实参类型相同；
  - 可变参数模板，可以处理不同类型的实参。（将在后面介绍）
- initializer_list类型表示某种特定类型的值的数组，和vector一样也是模板类型，所以必须跟`<T>`说明其中元素的类型。initilizer_list提供了一些常用的操作，也支持range for语句。当多个同类型实参传递给initializer_list的时候，要像这样`{a, b, c}`括起来。initializer_list中的元素都是const的。
- 另外还有一种省略符形参，涉及C++和C代码的交互，略。