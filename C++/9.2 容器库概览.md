# 9.2 容器库概览

- 容器类型上的操作分成三个层次，完整的列表查阅第295页：
  - 所有容器类型都提供的。
  - 顺序容器、关联容器或无序容器所特有的。
  - 某些容器自身特别支持的。
- 一般来说，每个容器都定义在一个头文件中，文件名与类型名相同。容器均定义为模板类，我们必须提供额外信息来生成特定的容器类型。对大多数容器来说，我们需要提供的是其中元素的类型。

## 9.2.1 迭代器

- 书上第96页的表格定义了容器迭代器支持的所有公共操作，其中有一个不符合公共接口特点的例外——forward_list迭代器不支持递减运算符，这也是很好理解的。书上第99页的表格列出了迭代器支持的算术运算，这些运算只能应用于string、vector、deque和array的迭代器，我们不能将它们用于其他任何容器类型的迭代器。**注意，迭代器之间没有加法运算，把两个迭代器相加相当于把两个地址相加，有什么卵用？**
- 迭代器范围（iterator range）的概念是标准库的基础，一个迭代器范围由一对迭代器表示，它们应该隶属于同一容器，且前一迭代器必须小于等于后一迭代器。**编译器不会强制上述要求，确保程序符合上述约定是程序员的责任。**

## 9.2.2 容器类型成员

- 每个容器都定义一些类型（见第295页的表格），之前我们使用过的有：size_type、iterator和const_iterator。除了上述三种迭代器类型，大多数容器还提供反向迭代器。简单地说，反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也相应发生了颠倒。除此以外，剩下的类型就是类型别名了，这些类型别名在泛型编程时非常有用。

## 9.2.3 begin 和 end 成员

- begin 和  end 有多个版本：带 r 的版本返回反向迭代器，以 c 开头的版本则返回const迭代器。不以 c 开头的begin、rbegin、end和rend都是重载过的，一个是const成员函数，一个是非const成员函数，以支持在常量容器和非常量容器上都能被调用。

## 9.2.4 容器定义和初始化

- 涉及容器定义和初始化相关的操作在第299页有汇总。

### 9.2.4.1 将一个容器初始为另一个容器的拷贝

- 将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者对一个迭代器对指定的元素范围进行拷贝（array不适用）。就前一种方式而言，必须要求参与拷贝的双方的容器类型及其元素类型完全相同；就后者而言，既不要求参与拷贝的双方的容器类型一致，也不要求其元素类型相同，只要它们的元素类型能够相互转换即可。因此，在不同容器类型之间相互拷贝赋值的时候，通常指定一个迭代器范围来完成。

### 9.2.4.2 列表初始化

- 略。

### 9.2.4.3  与顺序容器大小相关的构造操作

- 除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它会接受一个容器大小和一个可选的元素初始值。如果我们不提供元素初始值，标准库会创建一个值初始化器。
- **如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只提供一个容器大小参数；如果元素类型没有默认构造函数，除了大小参数外，还必须显式地指定元素初始值。**

### 9.2.4.4 标准库array具有固定大小

- 和内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：`array<int, 42>`、`array<string, 10>`。也就是说，单纯的`array<int>`不是一个类型，`array<int 10>`这种才算一个类型。
- 虽然我们不能对内置数组进行拷贝或对象赋值操作，但array容器类型并没有这个限制，只要参与赋值操作的双方元素类型以及大小相同即可。

## 9.2.5 赋值和swap

- 容器赋值运算汇总的表格见第302页。
- **使用swap**。一般来说，swap不会真正交换两个容器的元素，只是交换了两个容器的内部数据结构。也就是说，两个容器内的元素对象的内存地址不会发生改变，所以之前指向这些元素对象的迭代器、引用和指针都不会失效。上述规则有两个例外，一是string，该容器虽然也不真正交换两个容器之间的元素，但指向string容器内部元素的迭代器、引用和指针仍可能失效；二是array，该容器会真正交换两个容器之间的元素，所以指向array容器内部元素的迭代器、引用和指针将在交换后，指向交换后的对应值。
- C++11既提供成员函数版本的swap，也提供非成员版本的swap，后者在泛型编程中非常重要，应该养成统一使用后者的好习惯。

## 9.2.6  容器大小操作

- empty，size， max_size。 forward_list支持max_size和empty，不支持size。

## 9.2.7 关系运算符

- 每个容器都定义了 == 和 != 运算符；除了无序容器外的所有容器都支持 >、>=、<、<=。
- 容器的关系比较依赖于容器中元素的关系运算符，== 和 != 依赖于元素的 == ，其他关系运算符依赖于元素的 < ，如果容器中元素未定义这两个运算符，装载这些元素的容器也就不能进行相应的比较操作。